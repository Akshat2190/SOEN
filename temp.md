{
    "result": "/**\n * Determines if a number is prime, or returns its factors if it's not prime.\n *\n * This function handles various edge cases:\n * - Non-number, NaN, or non-integer inputs: Returns an empty array `[]`.\n * - Numbers less than 2 (e.g., 0, negative integers): Returns an empty array `[]`.\n * - The number 1: Returns `[1]` (as it's not prime, and its only factor is 1).\n * - The number 2: Returns `true` (as it's the only even prime number).\n * - Other even numbers: Returns an array of their factors.\n * - Odd composite numbers: Returns an array of their factors.\n * - Odd prime numbers: Returns `true`.\n *\n * @param {number} num The integer to check for primality.\n * @returns {true | number[]} `true` if the number is prime, otherwise an array of its positive integer factors,\n *                             sorted in ascending order.\n */\nfunction isPrimeOrGetFactors(num) {\n    // 1. Edge Case: Invalid input (non-number, NaN, non-integer)\n    if (typeof num !== 'number' || !Number.isInteger(num) || isNaN(num)) {\n        // These inputs are not prime, and their factors are not typically considered\n        // in the context of prime factorization. Returning an empty array signals invalid input\n        // within the \"return factors if not prime\" paradigm.\n        return [];\n    }\n\n    // 2. Edge Case: Numbers less than 2 (0, 1, negative integers)\n    if (num <= 1) {\n        // 1 is not prime, its only factor is 1.\n        // 0 and negative integers are not prime, and their factors are outside the\n        // typical scope of this problem. Returning an empty array for them.\n        return num === 1 ? [1] : [];\n    }\n\n    // 3. Optimization: 2 is the only even prime number\n    if (num === 2) {\n        return true;\n    }\n\n    // 4. Optimization: All other even numbers are not prime\n    if (num % 2 === 0) {\n        // The number is even and greater than 2, so it's composite.\n        // Find and return all its factors.\n        return getFactors(num);\n    }\n\n    // 5. Primality test for odd numbers: Check divisibility by odd numbers up to its square root.\n    // If a divisor is found, it's composite; otherwise, it's prime.\n    const limit = Math.sqrt(num);\n    for (let i = 3; i <= limit; i += 2) { // Iterate only through odd numbers\n        if (num % i === 0) {\n            // Found a divisor, so 'num' is not prime (it's composite).\n            // Find and return all its factors.\n            return getFactors(num);\n        }\n    }\n\n    // If the loop completes without finding any divisors, the number is prime.\n    return true;\n}\n\n/**\n * Helper function to find all positive integer factors of a given number.\n * This function is optimized for numbers greater than or equal to 2.\n *\n * @param {number} num The number (assumed to be a positive integer >= 2) to find factors for.\n * @returns {number[]} An array of positive integer factors, sorted in ascending order.\n */\nfunction getFactors(num) {\n    const factors = new Set(); // Using a Set to automatically handle duplicates and ensure uniqueness.\n\n    // Every number has 1 and itself as factors.\n    factors.add(1);\n    factors.add(num);\n\n    // Iterate from 2 up to the square root of num.\n    // If 'i' is a factor, then 'num / i' is also a factor.\n    const limit = Math.sqrt(num);\n    for (let i = 2; i <= limit; i++) {\n        if (num % i === 0) {\n            factors.add(i);\n            factors.add(num / i); // Add the corresponding quotient\n        }\n    }\n\n    // Convert the Set to an Array and sort it to ensure consistent output order.\n    return Array.from(factors).sort((a, b) => a - b);\n}\n"
}